<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="shared-styles.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../bower_components/iron-list/iron-list.html">
<link rel="import" href="../bower_components/polymerfire/firebase-query.html">
<link rel="import" href="../bower_components/paper-tooltip/paper-tooltip.html">
<link rel="import" href="../bower_components/app-storage/app-indexeddb-mirror/app-indexeddb-mirror.html">
<link rel="import" href="../bower_components/polymerfire/firebase-auth.html">
<link rel="import" href="../bower_components/polymer/lib/utils/render-status.html">
<link rel="import" href="redux-store.html">

<dom-module id="nc-nutrientsofinterest">
  <template>
    <style include="shared-styles">
      :host {
        display: block;

        padding: 10px;
      }

     .item.selected {
       background: #ccc;
     }

     .item {
       background: #fff;
     }
    </style>

    <!-- <app-indexeddb-mirror  id="nutrientsIndexedDB" key="nutrients"
    data="[[nutrientsQueried]]"
    persisted-data="{{nutrientsPersisted}}"></app-indexeddb-mirror> -->
    <firebase-auth
       id="auth"
       user="{{user}}"
       provider="google"
       signed-in="{{signedIn}}" >
    </firebase-auth>

    <firebase-query
      id="query"
      path="/nutrients"
      data="{{nutrientsQueried}}">
    </firebase-query>
    <firebase-query
      id="nutrientsOfInterestQuery"
      path="[[_getNutrientsOfInterestPath(user)]]"
      data="{{nutrientsOfInterestQueried}}">
    </firebase-query>

    <div class="card">
      <div class="circle">1</div>
      <paper-icon-button id="helpButton" icon="my-icons:help-outline"></paper-icon-button>
      <paper-tooltip for="helpButton" position="right">This screen is where you specify the nutrients you want to track.  You must select some nutrients to track before you can start entering food on the "consumption page" -- the next screen to visit and where you will spend most of your time in this app.</paper-tooltip>
      <h1>Nutrients of Interest</h1>

      <iron-list id="nutrientIronList" items="[[nutrientsPersisted]]" selected-items="{{selectedItems}}" selection-enabled multi-selection>
        <template>
        <div tabindex$="[[tabIndex]]" class$="[[_computedClass(selected)]]">[[item.name]]</div>
        </template>
      </iron-list>

    </div>
  </template>

  <script>
      class NcNutrientsOfInterest extends ReduxMixin(Polymer.Element){
      static get is() { return 'nc-nutrientsofinterest'; }

      static get properties() {
        return {
          data: {
            type: Array,
            statePath: 'nutrients',
          },
          offline: {
            type: Boolean,
            statePath: 'offline'
          },
          nutrientsQueried : Array,
          nutrientsOfInterestQueried: Array,
          nutrientsPersisted : Array,
          signedIn: Boolean,
          selectedItems: Array,
          refreshingSelectedItemsList: {
            type: Boolean,
            value: false
          },
        };
      }

      static get actions() {
        return {
          loadAllNutrients: (allNutrients) => {
            return {
                type: 'LOAD_ALL_NUTRIENTS',
                nutrients:  allNutrients
            }
          },
          loadAllNutrientsOfInterest: (allNutrientsOfInterest) => {
              return {
                type: 'LOAD_ALL_NUTRIENTS_OF_INTEREST',
                allNutrientsOfInterest:  allNutrientsOfInterest
              }
          },
        };
      }

      static get observers() {
        return [ 
          '_signedInChanged(signedIn)', 
           '_selectedItemsChanged(selectedItems.*)' //,
          // '_nutrientsOfInterestQueriedChanged(nutrientsOfInterestQueried.*)'
        ]; 
      }

      ready() {
        super.ready();
        this.doOffLineNutrientStuff();
      }

      _getNutrientsOfInterestPath(theUser) {
        if (!theUser) { return '';}
        return '/users/' + theUser.uid + '/nutrientsOfInterest';
      }

      _readNutrientsOfInterest() {
          if (!this.nutrientsPersisted || this.nutrientsPersisted.length === 0) { console.warn("_readNutrientsOfInterest() called when nutrients list was still empty!"); return;}
          let thisWebComponent = this;
          this._getNutrientsOfInterestFromIndexedDbIfAvailable()
            .then(() => {/* do nothing yet here */
                console.log("we got nutrients of interest from indexed db!");
            })
            .catch((errorText) => {
              console.log("_getNutrientsOfInterestFromIndexedDbIfAvailable promise rejected with error text...", errorText);
              if (!thisWebComponent.offline && thisWebComponent.signedIn) {
                thisWebComponent._setNutrientsOfInterestSelectedItemsFromFirebaseStore();

                // TODO if the errorText indicates the indexeddb database had no records or was undefined
                // and the firebase queried version shows some records then we need to update the indexeddb database,
                // perhaps by iterating over each element in the nutrients of interest's iron-lists list item
                // "option" elements and programmatically clicking on each one.
              }
            });
      }

      _setNutrientsOfInterestSelectedItemsFromFirebaseStore() {
        var thisWebComponent = this;
        return new Promise((resolve, reject) => {
          thisWebComponent.$.nutrientsOfInterestQuery.ref.on("value", function(snapshot) {
            console.log("the nutrients of interest firebase read came back successfully!");
            thisWebComponent._selectGivenNutrientsOfInterest(snapshot.val());
            //this.selectedItems = snapshot.val();
            resolve(snapshot.val());
          }.bind(thisWebComponent), function (errorObject) {
            console.warn("The nutrients of interest firebase read failed: " + errorObject.code);
            reject("The nutrients of interest firebase read failed: " + errorObject.code);
          });            
        });
      }

      _selectGivenNutrientsOfInterest(theList) {
        this.refreshingSelectedItemsList = true;
        var thisWebComponent = this;
        theList.forEach((item) => {
          thisWebComponent.$.nutrientIronList.selectIndex(item.offset);
          this.dispatch('loadAllNutrientsOfInterest', theList);      
        });
        this.refreshingSelectedItemsList = false;
      }

      _getNutrientsOfInterestFromIndexedDbIfAvailable () {
          let thisWebComponent = this;
          return new Promise((resolve, reject) => {
            var db;
            var request = window.indexedDB.open("NephcounterOffLineDB");
            request.onerror = function(event) {
                // Do something with request.errorCode!
                console.warn("NephcounterOffLineDB creation failed in _getNutrientsOfInterestFromIndexedDbIfAvailable!", event)
                reject("open of database failed with error in _getNutrientsOfInterestFromIndexedDbIfAvailable!");
            }; // end of onerror
            request.onsuccess = function(event) { 
              console.log("NephcounterOffLineDB open succeeded in _getNutrientsOfInterestFromIndexedDbIfAvailable!");
              db = event.target.result;
              if (!db.objectStoreNames.contains('nutrientsOfInterest')) {
                reject("nutrientsOfInterest object store has not been created yet to retrieve");
                console.warn("nutrientsOfInterest object store has not been created yet to retrieve", db.objectStoreNames);
                return;
              }
              var objectStore = db.transaction(["nutrientsOfInterest"], "readonly").objectStore("nutrientsOfInterest");
              var request = objectStore.get(1);
              request.onerror = function(event) {
                  // assuming that 1 was not found so it needs to be added
                  console.warn("Caught querying record 1 from nutrientsOfInterest from error in event: ", event);
                  reject("Caught querying record 1 from nutrientsOfInterest; check for console warning for specifics");
              };
              request.onsuccess = function(event) {
                // Get the old value that we want to update
                var data = event.target.result;
                
                if (typeof data === "undefined") {  // Then there is no record yet .
                  reject("there is no record yet in indexedDB");
                  return;
                }

                thisWebComponent._selectGivenNutrientsOfInterest(data.allNutrientsOfInterestList);
                //thisWebComponent.selectedItems = data.allNutrientsOfInterestList;
                resolve();
              };
  
            }; // end of onsuccess
  
            // This is done only if there is no database and one needs to be created before we read from it.
            request.onupgradeneeded = function(event) {   
              console.log("an upgrade is needed...");
              var db = event.target.result;
              reject("There is no offline database yet for nutrientsOfInterest");
            }; // end of onupgradeneeded
          });
      }

      _nutrientsOfInterestQueriedChanged (changeRecord) {
        if (!changeRecord || !changeRecord.base) { return; }
        console.log('nutrients of interest queried has ' + changeRecord.base.length + ' records!');
      }

      _selectedItemsChanged (changeRecord) {
        if (
          this.refreshingSelectedItemsList ||
          typeof changeRecord === "undefined" || 
          typeof changeRecord.base === "undefined" ||
          changeRecord.base.length === 0
        ) {  return; }
        // 1.  write to firebase if logged in and online
        if (!this.offline && this.signedIn) {
          this.writeNutrientsOfInterestToFirebase(changeRecord.base);
        }
        // 2.  write to indexeddb
        this.saveNutrientsOfInterestToIndexedDb(changeRecord.base)
          .catch((errTxt) => { console.warn("The following error was caught from saveNutrientsOfInterestToIndexedDb call: ", errTxt); });
        // 3.  update redux  
        this.dispatch('loadAllNutrientsOfInterest', changeRecord.base);      
      }

      writeNutrientsOfInterestToFirebase(nutrientsOfInterestList) {
        let updateRef = this.$.nutrientsOfInterestQuery.ref;// TODO test this.
        updateRef.set(nutrientsOfInterestList);
      }

      saveNutrientsOfInterestToIndexedDb (nutrientsOfInterestList) {
          
        return new Promise((resolve, reject) => {
          var db;
          var request = window.indexedDB.open("NephcounterOffLineDB");
          request.onerror = function(event) {
              // Do something with request.errorCode!
              console.log("NephcounterOffLineDB creation failed!", event)
              reject("open of database failed with error!");
          }; // end of onerror
          request.onsuccess = function(event) { 
            console.log("NephcounterOffLineDB open succeeded!");
            db = event.target.result;
            if (!db.objectStoreNames.contains('nutrientsOfInterest')) {
              reject("nutrientsOfInterest object store has not been created yet to save");
              console.warn("nutrientsOfInterest object store has not been created yet to save", db.objectStoreNames);
              return;
            }
            var objectStore = db.transaction(["nutrientsOfInterest"], "readwrite").objectStore("nutrientsOfInterest");
            var request = objectStore.get(1);
            request.onerror = function(event) {
                // assuming that 1 was not found so it needs to be added
                console.warn("Caught querying record 1 from nutrientsOfInterest from error in event: ", event);
                reject("Caught querying record 1 from nutrientsOfInterest; check for console warning for specifics");
            };
            request.onsuccess = function(event) {
              // Get the old value that we want to update
              var data = event.target.result;
              
              if (typeof data === "undefined") {  // Then there is no record yet and we must add rather than update.
                var possibleNutrientsObjectStore = db.transaction("nutrientsOfInterest", "readwrite").objectStore("nutrientsOfInterest");
                var request = possibleNutrientsObjectStore.add({allNutrientsOfInterestListKey: 1, allNutrientsOfInterestList: nutrientsOfInterestList});
                request.onsuccess = (event) => { 
                  console.log("added nutrients of interest to indexeddb");
                  resolve();
                }
                return;
              }

              // update the value(s) in the object that you want to change
              data.allNutrientsOfInterestList = nutrientsOfInterestList;

              // Put this updated object back into the database.
              var requestUpdate = objectStore.put(data);
              requestUpdate.onerror = function(event) {
                console.warn("rejecting nutrient of interest indexeddb update due to event:", event);
                reject("rejecting nutrient of interest indexeddb update");
              };
              requestUpdate.onsuccess = function(event) {
                console.log("updated nutrients of interest in indexeddb");
                resolve();
              };
            };

          }; // end of onsuccess

          // This is done only if there is no database and one needs to be created before we read from it.
          request.onupgradeneeded = function(event) {   
              console.log("an upgrade is needed...");
              var db = event.target.result;
          }; // end of onupgradeneeded
        });
      }

      doOffLineNutrientStuff() {
        let thisWebComponent = this;
        this.waitForIndexedDbToOpenAndReadOrFail()
          .then(() => {
            console.log("waitForIndexedDbToOpenAndReadOrFail success!");
            thisWebComponent._doStuffOnceNutrientsHaveLoaded();
          })
          .catch(errMsg => { 
            console.log("in catch with error message of ", errMsg);
            return new Promise((resolve, reject) => {
              console.log("entered into the promise being returned in the catch...", thisWebComponent.signedIn);
              if (!thisWebComponent.signedIn) { // not good to query if not signed in.
                reject("Don't query if not signed in");
                return;
              }
              thisWebComponent.$.query.ref.on("value", function(snapshot) {
                console.log("the firebase read came back successfully!");
                resolve(snapshot.val());
              }.bind(this), function (errorObject) {
                console.warn("The read failed: " + errorObject.code);
                reject("The read failed: " + errorObject.code);
              });            
            });
          })
            .then((nutrientArray) => { 
              console.log("go work with nutrient array: ", nutrientArray);
              thisWebComponent.waitForIndexedDbToOpenAndReadOrFail(nutrientArray)
              .then(() => {
                console.log("waitForIndexedDbToOpenAndReadOrFail call 2 succeeded.");
                thisWebComponent._doStuffOnceNutrientsHaveLoaded();
              })
              .catch(() => { 
                console.warn("waitForIndexedDbToOpenAndReadOrFail failed again...time to delete the db and try a third time with the array in hand.");
                thisWebComponent.deleteDB()
                .then(() => {
                  thisWebComponent.waitForIndexedDbToOpenAndReadOrFail(nutrientArray)
                    .then(() => {
                      console.log("waitForIndexedDbToOpenAndReadOrFail call 3 succeeded.");
                      thisWebComponent._doStuffOnceNutrientsHaveLoaded();
                    })
                    .catch(() => {console.log("waitForIndexedDbToOpenAndReadOrFail call 3 failed.")});
                })
                .catch(() => {console.warn("NephcounterOffLineDB database delete failed.")});
              });
            })
            .catch(() => {console.warn("In promise catch section.");});
      }

      _doStuffOnceNutrientsHaveLoaded() {
        //this._readNutrientsOfInterest(); // TODO -- this did not work...even though the 
        // nutrients array is populated, iron-list is still not showing anything yet.  
        // Need to find a way to make sure that has happened...call this method afterNextRender from here??
        Polymer.RenderStatus.afterNextRender(this, function() {
          this._readNutrientsOfInterest();
        });
     }

      deleteDB() {
        var thisWebComponent = this;
        return new Promise((resolve, reject) => {
          var DBDeleteRequest = window.indexedDB.deleteDatabase("NephcounterOffLineDB");

          DBDeleteRequest.onerror = function(event) {
            console.log("Error deleting database.");
            reject();
          };
          
          DBDeleteRequest.onsuccess = function(event) {
            console.log("Database deleted successfully");
              
            console.log(event.result); // should be undefined
            resolve();
          };          
        });
      }

      waitForIndexedDbToOpenAndReadOrFail(nutrientsArrayFromDB) {
        var thisWebComponent = this;
        return new Promise((resolve, reject) => {
          if (typeof thisWebComponent.signedIn === "undefined" || !thisWebComponent.signedIn) {
              reject("not signed in yet");
              return;
          }
          var db;
          var request = window.indexedDB.open("NephcounterOffLineDB");
          request.onerror = function(event) {
            // Do something with request.errorCode!
            console.log("NephcounterOffLineDB creation failed!", event);
            reject("NephcounterOffLineDB creation failed!");
          };
          // This is done once/if the database exists with the data in it.
          request.onsuccess = function(event) {
            // Do something with request.result!
            console.log("NephcounterOffLineDB creation succeeded!")
            db = event.target.result;
            var transaction; 
            try {
              transaction = db.transaction(["possibleNutrients"], "readonly");
            } catch (e) {
              console.warn("Why did creating the transaction fail??", e);
              reject("get data from database");
              return;
            }
            // report on the success of the transaction completing, when everything is done
            transaction.oncomplete = function(event) {
              //console.log("everything is completed in the transaction.", event);
            };

            transaction.onerror = function(event) {
              console.warn("transaction not opened due to error", event);
              reject("transaction open came back with an error");
            };

            var objectStore = transaction.objectStore("possibleNutrients");
             var dataRequest = objectStore.get(1);
            dataRequest.onerror = function(event) {
              // Handle errors!
              console.warn("The data request ended in an error...", event);
              reject("The data request ended in an error...");
            };
            dataRequest.onsuccess = function(event) {
              if (!dataRequest || !dataRequest.result) {
                reject("somehow objectStore record has not been created yet...");
                return;
              }
              thisWebComponent.nutrientsPersisted = dataRequest.result.allNutrientsList;
              resolve();
            };


          };

          // This is done only if there is no database and one needs to be created before we read from it.
          request.onupgradeneeded = function(event) {
              console.log("an upgrade is needed...");
              var db = event.target.result;
              if (!db.objectStoreNames.contains('possibleNutrients') && nutrientsArrayFromDB) {
                  let objectStore = db.createObjectStore("possibleNutrients", { keyPath: "allNutrientsListKey" });
                  // Use transaction oncomplete to make sure the objectStore creation is
                  // finished before adding data into it.
                  objectStore.transaction.oncomplete = function(event) {
                    // Store values in the newly created objectStore.
                    var possibleNutrientsObjectStore = db.transaction("possibleNutrients", "readwrite").objectStore("possibleNutrients");
                        possibleNutrientsObjectStore.add({allNutrientsListKey: 1, allNutrientsList: nutrientsArrayFromDB});
                    thisWebComponent.nutrientsPersisted = nutrientsArrayFromDB;
                  };
              }
              if (!db.objectStoreNames.contains('nutrientsOfInterest')) {
                let nutrientsOfInterestObjectStore = db.createObjectStore("nutrientsOfInterest", { keyPath: "allNutrientsOfInterestListKey" });
              }
              console.log("NephcounterOffLineDB has finished its upgrade.")
          };
        });
      }

      _computedClass(isSelected) {
        var classes = 'item';
        if (isSelected) {
          classes += ' selected';
        }
        return classes;
      }

      iconForItem(isSelected) {
        return isSelected ? 'my-icons:star' : 'my-icons:star-border';
      }
      _unselect(e) {
        this.$.itemsList.deselectItem(e.model.item);
      }
      _getFormattedCount(count) {
        return count > 0 ? '(' + count + ')' : '';
      }

      _nutrientsQueriedChanged(changeRecord) {
        console.log("here is the nutrientsQueried base: ", changeRecord.base);
      }

      _signedInChanged(newValue, oldValue) {
        console.log("new value:", newValue);
        console.log("old value:", oldValue);
        if (!newValue) {
          return;
        }
        this.doOffLineNutrientStuff();
       }

    }

    window.customElements.define(NcNutrientsOfInterest.is, NcNutrientsOfInterest);
  </script>
</dom-module>
