<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="shared-styles.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../bower_components/paper-tooltip/paper-tooltip.html">
<link rel="import" href="../bower_components/iron-list/iron-list.html">
<link rel="import" href="../bower_components/polymerfire/firebase-query.html">
<link rel="import" href="../bower_components/app-storage/app-indexeddb-mirror/app-indexeddb-mirror.html">
<link rel="import" href="../bower_components/polymerfire/firebase-auth.html">
<link rel="import" href="redux-store.html">

<dom-module id="nc-nutrientsofinterest">
  <template>
    <style include="shared-styles">
      :host {
        display: block;

        padding: 10px;
      }

     .item.selected {
       background: #ccc;
     }

     .item {
       background: #fff;
     }
    </style>

    <!-- <app-indexeddb-mirror  id="nutrientsIndexedDB" key="nutrients"
    data="[[nutrientsQueried]]"
    persisted-data="{{nutrientsPersisted}}"></app-indexeddb-mirror> -->
    <firebase-query
      id="query"
      path="/nutrients"
      data="{{nutrientsQueried}}">
    </firebase-query>
    <firebase-auth
       id="auth"
       user="{{user}}"
       provider="google"
       signed-in="{{signedIn}}" >
    </firebase-auth>


    <div class="card">
      <div class="circle">1</div>
      <paper-icon-button id="helpButton" icon="my-icons:help-outline"></paper-icon-button>
      <paper-tooltip for="helpButton" position="right">This screen is where you specify the nutrients you want to track.  You must select some nutrients to track before you can start entering food on the "consumption page" -- the next screen to visit and where you will spend most of your time in this app.</paper-tooltip>
      <h1>Nutrients of Interest</h1>

      <iron-list id="nutrientIronList" items="[[nutrientsPersisted]]" selected-items="{{selectedItems}}" selection-enabled multi-selection>
        <template>
        <div tabindex$="[[tabIndex]]" class$="[[_computedClass(selected)]]">[[item.name]]</div>
        </template>
      </iron-list>

    </div>
  </template>

  <script>
      class NcNutrientsOfInterest extends ReduxMixin(Polymer.Element){
      static get is() { return 'nc-nutrientsofinterest'; }

      static get properties() {
        return {
          data: {
            type: Array,
            statePath: 'nutrients',
          },
          nutrientsQueried : Array,
          nutrientsPersisted : Array,
          signedIn: Boolean,
          selectedItems: Array,
        };
      }

      static get actions() {
        return {
          loadAllNutrients: function (allNutrients) {
            return {
                type: 'LOAD_ALL_NUTRIENTS',
                nutrients:  allNutrients
            }
          },
          loadAllNutrientsOfInterest: (allNutrientsOfInterest) => {
              return {
                type: 'LOAD_ALL_NUTRIENTS_OF_INTEREST',
                allNutrientsOnInterest:  allNutrientsOfInterest
              }
          },
        };
      }

      static get observers() {
        return [ '_signedInChanged(signedIn)', '_selectedItemsChanged(selectedItems.*)'
        ]; //  , '_nutrientsPersistedChanged(nutrientsPersisted.*)'  '_nutrientsQueriedChanged(nutrientsQueried.*)'
      }

      ready() {
        super.ready();
        this.doOffLineNutrientStuff();
      }

      _selectedItemsChanged (changeRecord) {
        console.log('path: ' + changeRecord.path);
        console.log('value: ' + changeRecord.value);
        // What could I do here?
        // 1.  write to firebase if logged in and online
        // 2.  write to indexeddb
        // 3.  update redux  
        this.dispatch('loadAllNutrientsOfInterest', changeRecord.base)      
      }

      doOffLineNutrientStuff() {
        let thisWebComponent = this;
        this.waitForIndexedDbToOpenAndReadOrFail()
          .then(() => {console.log("waitForIndexedDbToOpenAndReadOrFail success!")})
          .catch(errMsg => { 
            console.log("in catch with error message of ", errMsg);
            return new Promise((resolve, reject) => {
              console.log("entered into the promise being returned in the catch...", thisWebComponent.signedIn);
              if (!thisWebComponent.signedIn) { // not good to query if not signed in.
                reject("Don't query if not signed in");
                return;
              }
              thisWebComponent.$.query.ref.on("value", function(snapshot) {
                console.log("the firebase read came back successfully!");
                resolve(snapshot.val());
              }.bind(this), function (errorObject) {
                console.warn("The read failed: " + errorObject.code);
                reject("The read failed: " + errorObject.code);
              });            
            });
          })
            .then((nutrientArray) => { 
              console.log("go work with nutrient array: ", nutrientArray);
              thisWebComponent.waitForIndexedDbToOpenAndReadOrFail(nutrientArray)
              .then(() => {console.log("waitForIndexedDbToOpenAndReadOrFail call 2 succeeded.");})
              .catch(() => { 
                console.warn("waitForIndexedDbToOpenAndReadOrFail failed again...time to delete the db and try a third time with the array in hand.");
                thisWebComponent.deleteDB()
                .then(() => {
                  thisWebComponent.waitForIndexedDbToOpenAndReadOrFail(nutrientArray)
                    .then(() => {console.log("waitForIndexedDbToOpenAndReadOrFail call 3 succeeded.")})
                    .catch(() => {console.log("waitForIndexedDbToOpenAndReadOrFail call 3 failed.")});
                })
                .catch(() => {console.warn("NephcounterOffLineDB database delete failed.")});
              });
            })
            .catch(() => {console.warn("In promise catch section.");});
      }

      deleteDB() {
        var thisWebComponent = this;
        return new Promise((resolve, reject) => {
          var DBDeleteRequest = window.indexedDB.deleteDatabase("NephcounterOffLineDB");

          DBDeleteRequest.onerror = function(event) {
            console.log("Error deleting database.");
            reject();
          };
          
          DBDeleteRequest.onsuccess = function(event) {
            console.log("Database deleted successfully");
              
            console.log(event.result); // should be undefined
            resolve();
          };          
        });
      }

      waitForIndexedDbToOpenAndReadOrFail(nutrientsArrayFromDB) {
        var thisWebComponent = this;
        return new Promise((resolve, reject) => {
          if (typeof thisWebComponent.signedIn === "undefined" || !thisWebComponent.signedIn) {
              reject("not signed in yet");
              return;
          }
          var db;
          var request = window.indexedDB.open("NephcounterOffLineDB");
          request.onerror = function(event) {
            // Do something with request.errorCode!
            console.log("NephcounterOffLineDB creation failed!", event)
          };
          // This is done once/if the database exists with the data in it.
          request.onsuccess = function(event) {
            // Do something with request.result!
            console.log("NephcounterOffLineDB creation succeeded!")
            db = event.target.result;
            var transaction; 
            try {
              transaction = db.transaction(["possibleNutrients"], "readonly");
            } catch (e) {
              console.warn("Why did creating the transaction fail??", e);
              reject("get data from database");
              return;
            }
            // report on the success of the transaction completing, when everything is done
            transaction.oncomplete = function(event) {
              //console.log("everything is completed in the transaction.", event);
            };

            transaction.onerror = function(event) {
              console.warn("transaction not opened due to error", event);
            };

            var objectStore = transaction.objectStore("possibleNutrients");
             var dataRequest = objectStore.get(1);
            dataRequest.onerror = function(event) {
              // Handle errors!
              console.warn("The data request ended in an error...", event);
            };
            dataRequest.onsuccess = function(event) {
              thisWebComponent.nutrientsPersisted = dataRequest.result.allNutrientsList;
              resolve();
            };
          };

          // This is done only if there is no database and one needs to be created before we read from it.
          request.onupgradeneeded = function(event) {
              console.log("an upgrade is needed...");
              var db = event.target.result;
              if (!db.objectStoreNames.contains('possibleNutrients') && nutrientsArrayFromDB) {
                  // Create an objectStore for this database
                  var objectStore = db.createObjectStore("possibleNutrients", { keyPath: "allNutrientsListKey" });
                  // Use transaction oncomplete to make sure the objectStore creation is
                  // finished before adding data into it.
                  objectStore.transaction.oncomplete = function(event) {
                    // Store values in the newly created objectStore.
                    var possibleNutrientsObjectStore = db.transaction("possibleNutrients", "readwrite").objectStore("possibleNutrients");
                        possibleNutrientsObjectStore.add({allNutrientsListKey: 1, allNutrientsList: nutrientsArrayFromDB});
                    thisWebComponent.nutrientsPersisted = nutrientsArrayFromDB;
                  };
              }
              console.log("NephcounterOffLineDB needs an upgrade!")
          };
        });
      }


      _computedClass(isSelected) {
        var classes = 'item';
        if (isSelected) {
          classes += ' selected';
        }
        return classes;
      }

      iconForItem(isSelected) {
        return isSelected ? 'my-icons:star' : 'my-icons:star-border';
      }
      _unselect(e) {
        this.$.itemsList.deselectItem(e.model.item);
      }
      _getFormattedCount(count) {
        return count > 0 ? '(' + count + ')' : '';
      }

      _nutrientsQueriedChanged(changeRecord) {
        console.log("here is the nutrientsQueried base: ", changeRecord.base);
      }

      _signedInChanged(newValue, oldValue) {
        console.log("new value:", newValue);
        console.log("old value:", oldValue);
        if (!newValue) {
          return;
        }
        this.doOffLineNutrientStuff();
       }

    }

    window.customElements.define(NcNutrientsOfInterest.is, NcNutrientsOfInterest);
  </script>
</dom-module>
